unit testion and junit

->unittesting
   gives early look in quality
   breaking doen a system into its components

junit=automation and repeatability to allow more testiong more oftens


junit
 adding the junit ->properties->java build path->libreries->add junit lib
 adding java test classes -> select wizard ->java->junit-> 
 
 --------------------------------------------------------------------------------------------------------------------
 JUnit 4-> has everything bundled into single jar file.requires java 5 or higher

Junit 5-> is composed of 3 sub-projects i.e. JUnit Platform, JUnit Jupiter and JUnit Vintage. requires java8 and higher

JUnit Platform
---------------
It defines the TestEngine API for developing new testing frameworks that runs on the platform.

JUnit Jupiter
---------------
It has all new junit annotations and TestEngine implementation to run tests written with these annotations.

JUnit Vintage
---------------
To support running JUnit 3 and JUnit 4 written tests on the JUnit 5 platform.
 
 
 FEATURE                                               	 JUNIT 4	            JUNIT 5
Declare a test method	                                  @Test	               @Test
Execute before all test methods in the current class  	 @BeforeClass        	@BeforeAll
Execute after all test methods in the current class	    @AfterClass	          @AfterAll
Execute before each test method                         	 @Before              	 @BeforeEach
Execute after each test method	                          @After	                 @AfterEach
Disable a test method / class	                             @Ignore	              @Disabled
Test factory for dynamic tests                             NA	                    @TestFactory
Nested tests	                                            NA	                    @Nested
Tagging and filtering	                                   @Category	              @Tag
Register custom extensions                                 NA	                    @ExtendWith 





 assert -fource full start
 
Junit 4-> org.junit.Assume contains methods for stating assumptions about the conditions in which a test is meaningful. It has following five methods:
----------------------
assumeFalse()
assumeNoException()
assumeNotNull()
assumeThat()
assumeTrue()

Junit 5->org.junit.jupiter.api.Assumptions contains methods for stating assumptions about the conditions in which a test is meaningful. It has following three methods:
--------------------------
assumeFalse()
assumingThat()
assumeTrue()


 fall("not yet implemented");--error if the code is not difined
 
 definng test in junit
 
 running from java code
 general Assertions
 Number Equality
 Object Equality
 array Equality
 Basic assert That Options
 combinations and assert that
 custom assertThat Matchers
 Assume versus Assert
 Setting up test Cases
 Test Fixtures
 

mocking
-----------
mockito + junit
->mocking refers to the development of the object which are a mock or clone of real objects.
->in the technique mock objects are used instead of real objects for testing.
(for every input it gives some output)

mockito
---------
->Mockito is an open source framework that allows you to easily create test doubles (mocks). Test Double is a generic term for any case where you replace a production object for testing purposes.
->mockito is a java based framework used for unit testing of java applications.
->this mocking framework helps in development of testable applications.
(validating the behaviour of the application or framework)


setting the mockito
----------------------------
To add mockito into the project,add jar file in pom.xml.

pom.xml
-------
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <version>2.23.4</version>
    <scope>test</scope>
</dependency>



mackito annotations
-------------------
->@Mock is used for mock creation. It makes the test class more readable.
->@Spy is used to create a spy instance. We can use it instead spy(Object) method.
->@InjectMocks is used to instantiate the tested object automatically and inject all the @Mock or @Spy annotated field dependencies into it (if applicable).
->@Captor is used to create an argument captor.


@mock and @injectMocks 
-------------------------
@Mock – creates mocks
@InjectMocks – creates objects and inject mocked dependencies

Use @InjectMocks to create class instances which needs to be tested in test class.
Use @InjectMocks when actual method body needs to be executed for a given class.
Use @InjectMocks when we need all internal dependencies initialized with mock objects to work method correctly.
Use @Mock to create mocks which are needed to support testing of class to be tested.
Annotated class (to be tested) dependencies with @Mock annotation.
We must define the when-thenRetrun methods for mock objects which class methods will be invoking during actual test execution.
-------------------------------------------
To process with  annotations, MockitoAnnotations.initMocks(testClass); must be used mat least once
we can use the built-in runner MockitoJUnitRunner or rule MockitoRule


example:
@RunWith(MockitoJUnitRunner.class)
public class ApplicationTest {
  @Rule public MockitoRule rule = MockitoJUnit.rule().strictness(Strictness.STRICT_STUBS);
  @Before
    public void init() {
        MockitoAnnotations.initMocks(this);
    }
    }


Mockito – Verify multiple method calls with different arguments
--------------------------------------------------------------------
The given unit test has mocked the HashMap class and invokes in put(key, value) code twice. It then verifies that method had been invoked twice. The test further verifies all the different method arguments separately.

example:-
import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.times;
 
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
 
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.MockitoJUnitRunner;
 
@RunWith(MockitoJUnitRunner.class)
public class MockitoExample 
{
    @Mock
    HashMap<String, Integer> hashMap;
 
    @Captor
    ArgumentCaptor<String> keyCaptor;
 
    @Captor
    ArgumentCaptor<Integer> valueCaptor;
    (Create as many ArgumentCaptor instances as the number of arguments in the method. In above example, we tested the HashMap which work on key-value pairs, so we created two ArgumentCaptor instances – one for key and second for value.)
    
    @Test
    public void saveTest() 
    {
        hashMap.put("A", 10);
        hashMap.put("B", 20);
         
        //1. Verify method was invoked N times
         
        Mockito.verify(hashMap, times(2)).put(keyCaptor.capture(), valueCaptor.capture());
           //(Use Mockito.verify(mock, times(n)) to verify if method was executed 'n' times.)
        List<String> keys = keyCaptor.getAllValues();
        List<Integer> values = valueCaptor.getAllValues();
         
        //2. Verify method argument values as list
 
        assertEquals(Arrays.asList("A", "B"), keys);
        assertEquals(Arrays.asList(Integer.valueOf(10), Integer.valueOf(20)), values);
         
        //3. Verify method arguments separately
         
        assertEquals("A", keys.get(0));
        assertEquals("B", keys.get(1));
         
        assertEquals(Integer.valueOf(10), values.get(0));
        assertEquals(Integer.valueOf(20), values.get(1));
    }
}



Use ArgumentCaptor.getAllValues() to retrieve all the values passed to one method parameter during all executions. It returns a List of passed argument values.
We can use assertEquals(expected, result) to verify that expected multiple arguments match with the retrieved values from ArgumentCaptor.


mockito with springboot
-------------------------
pom.xml
--------
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.12</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <version>2.15.0</version>
</dependency>
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-inline</artifactId>
    <version>2.15.0</version>
</dependency>

-------------------------------------------------------

powermock 
adding power mock dependencies to meven project



junit 
mockito
mockito annotations
power mock
example for junit with mockito 
and covering test case in project -createOperation
creating one test case 



getting started with maockito

unit test are used to test individual units of code in contract to integration test
which focus on the interconnections


mock objects are the stimulations of real objects
this are used because the real objects are often complex

and can't directly used in testing environment
mocks are actually objects of a class derived from real objects class

the functions in these mocks can be stubbed to return a specific value

we emphasize that these mocks aren't directly being tested rather they are objects on which the object thats being tested depends on

mockito is possibly the most popular java library for building and using mocks


-------------
practical
------------

dependancies to project regarding mockito and junit through its pom.xml file

mock methods
when.thenReturn syntax

creating mocks and verifing behavior


@BeforeEach =Perform an operation at the beginning of a test case
@Test       =Run a unit test for a particular operation
@AfterEach  =Perform an operation when each test case is complete



create an iterator mock containing these values

Iterator<String> iteratorMock = mock(Iterator.class);
   when(iteratorMock.next()).thenReturn("Peter")
                            .thenReturn("John")
                            .thenReturn("Alice");

Mockito allows you to create dummy objects for the dependencies of the object under test
Selected

You would like to create a new Maven project with built in dependencies for JUnit. Which of the following commands could you use to achieve this?
mvn archetype:generate \
   -DgroupId=com.skillsoft.mocks \
   -DartifactId=mocks-project \
   -DarchetypeArtifactId=maven-archetype-quickstart \
   -DinteractiveMode=false

